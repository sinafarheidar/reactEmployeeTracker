"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
exports.useCanHover = () => {
    // assume that if device is smaller than 500 there's no hover, but actually check it on the first touch event
    const [canHover, setCanHover] = react_1.useState(window.innerWidth > 500);
    react_1.useEffect(() => {
        // mobile devices also emit a "mousemove" on every touch (#theplatform<3), but desktop devices don't emit "touchstart"
        const eventName = 'touchstart';
        window.addEventListener(eventName, function onFirstTouch() {
            setCanHover(false);
            window.removeEventListener(eventName, onFirstTouch, false);
        }, false);
    }, []);
    return canHover;
};
exports.useHovered = () => {
    const [hovering, setHovering] = react_1.useState(false);
    const canHover = exports.useCanHover();
    return {
        value: hovering,
        setValue: setHovering,
        bind: canHover
            ? {
                onMouseOver: () => setHovering(true),
                onMouseLeave: () => setHovering(false),
            }
            : {
                onClick: () => setHovering(h => !h),
            },
    };
};
exports.useToggleBodyClass = (bool, [on, off]) => {
    react_1.useEffect(() => {
        document.body.classList.remove(bool ? off : on);
        document.body.classList.add(bool ? on : off);
    });
};
exports.usePose = (initial, poses = {}) => {
    const [pose, setPose] = react_1.useState(initial);
    return { pose, setPose, poses };
};
exports.useVisiblePose = (initial) => {
    const VISIBLE = 'visible';
    const HIDDEN = 'hidden';
    const _a = exports.usePose(initial ? VISIBLE : HIDDEN, [HIDDEN, VISIBLE]), { setPose, pose } = _a, rest = __rest(_a, ["setPose", "pose"]);
    return [pose, (v) => setPose(v ? VISIBLE : HIDDEN), rest];
};
function gtag(...args) {
    // @ts-ignore
    window.dataLayer.push(args);
}
exports.useGoogleAnalytics = (id, startLoading) => {
    react_1.useEffect(() => {
        if (!id) {
            return;
        }
        if (startLoading) {
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = `https://www.googletagmanager.com/gtag/js?id=${id}`;
            document.body.appendChild(script);
            // @ts-ignore
            window.dataLayer = window.dataLayer || [];
            gtag('js', new Date());
            gtag('config', id, {
                anonymize_ip: true,
                cookie_expires: 0,
            });
        }
    }, [id, startLoading]);
};
exports.useFindElementCenter = (elementRef) => {
    const [windowSize, setWindowSize] = react_1.useState();
    react_1.useEffect(() => {
        if (elementRef.current) {
            const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = elementRef.current;
            setWindowSize({
                x: window.innerWidth / 2 - offsetWidth / 2 - offsetLeft,
                y: window.innerHeight / 2 - offsetHeight / 2 - offsetTop,
            });
        }
    }, [elementRef]);
    return windowSize;
};
exports.useMousePosition = (shouldTrack) => {
    const [mousePosition, setMousePosition] = react_1.useState({ x: 0, y: 0 });
    const canHover = exports.useCanHover();
    react_1.useEffect(() => {
        if (canHover && shouldTrack) {
            const handler = ({ clientX, clientY }) => {
                setMousePosition({
                    x: clientX,
                    y: clientY,
                });
            };
            window.document.addEventListener('mousemove', handler);
            return () => window.document.removeEventListener('mousemove', handler);
        }
        return () => { };
    }, [canHover, shouldTrack]);
    return canHover ? mousePosition : {};
};
exports.useClock = (timeFormattingFunction = date => date.toLocaleDateString()) => {
    const getCurrentTime = react_1.useCallback(() => timeFormattingFunction(new Date()), [timeFormattingFunction]);
    const [time, setTime] = react_1.useState(getCurrentTime());
    react_1.useEffect(() => {
        const t = setInterval(() => setTime(getCurrentTime()), 1000);
        return () => clearInterval(t);
    }, [getCurrentTime]);
    return time;
};
exports.useOnPageLoad = () => {
    const [loaded, setLoaded] = react_1.useState(false);
    react_1.useEffect(() => {
        window.onload = () => setLoaded(true);
    }, []);
    return loaded;
};
exports.useLoadScript = ({ startLoading, src }) => {
    const [state, setState] = react_1.useState({
        ready: false,
        error: null,
    });
    react_1.useEffect(() => {
        if (startLoading) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => setState({ ready: true, error: null });
            script.onerror = error => setState({ ready: false, error });
            document.body.appendChild(script);
        }
    }, [src, startLoading]);
    return state;
};
exports.useScript = (props) => exports.useLoadScript(props);
exports.useDelay = (ms) => {
    const [done, setDone] = react_1.useState(false);
    react_1.useEffect(() => {
        setTimeout(() => {
            setDone(true);
        }, ms);
    }, [ms]);
    return done;
};
//# sourceMappingURL=useSizzyHooks.js.map